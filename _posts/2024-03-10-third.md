---
layout: single
title: "Tracing kthread_create"
categories: Linux_kernel
toc: true
author_profile: true
tag: [Linux, kernel, Kthread, tracing]
share: false
---

## /rpi_kernel_src/linux/include/linux # vi kthread.h
``` c
27 #define kthread_create(threadfn, data, namefmt, arg...) \
28 	kthread_create_on_nede(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)
```

>threadfn : function handler, function pointer
>data : struct
>namefmt : string for naming a thread
>arg... : a variadic macro that accepts format specifiers included in namefmt. It is used to format the name of the thread.

>include/linux/numa.h : 14 # define NUMA_NO_NODE (-1)

## /rpi_kernel_src/linux/include/linux # vi kthread.h
```c
11 struct task_struct *kthread_create_on_node(int (*threadfn)(void *data), 
                                            void *data, 
                                            int node, 
                                            const char namefmt[], 
                                            ...
                                            );
```


> (*threadfn)(void *data) : field for storing the address of handler function, which defines detailed behaviours of the thread
> void *data : parameters passed to the handler function, typically passing the address of a structure
> include/linux/numa.h : 14 # define NUMA_NO_NODE (-1) : set -1 as a default value
> const char namefmt[] : storing the name of the kernel thread

## /rpi_kernel_src/linux/kernel # vi kthread.c
```c
 480 /**
 481  * kthread_create_on_node - create a kthread.
 482  * @threadfn: the function to run until signal_pending(current).
 483  * @data: data ptr for @threadfn.
 484  * @node: task and thread structures for the thread are allocated on this node
 485  * @namefmt: printf-style name for the thread.
 486  *
 487  * Description: This helper function creates and names a kernel
 488  * thread.  The thread will be stopped: use wake_up_process() to start
 489  * it.  See also kthread_run().  The new thread has SCHED_NORMAL policy and
 490  * is affine to all CPUs.
 491  *
 492  * If thread is going to be bound on a particular cpu, give its node
 493  * in @node, to get NUMA affinity for kthread stack, or else give NUMA_NO_NODE.
 494  * When woken, the thread will run @threadfn() with @data as its
 495  * argument. @threadfn() can either return directly if it is a
 496  * standalone thread for which no one will call kthread_stop(), or
 497  * return when 'kthread_should_stop()' is true (which means
 498  * kthread_stop() has been called).  The return value should be zero
 499  * or a negative error number; it will be passed to kthread_stop().
 500  *
 501  * Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).
 502  */
 503 struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
 504                                            void *data, int node,
 505                                            const char namefmt[],
 506                                            ...)
 507 {
 508         struct task_struct *task;
 509         va_list args;
 510
 511         va_start(args, namefmt);
 512         task = __kthread_create_on_node(threadfn, data, node, namefmt, args);
 513         va_end(args);
 514
 515         return task;
 516 }
 517 EXPORT_SYMBOL(kthread_create_on_node);
 518
```

> va_start(args, namegmt) : to process the variable arguments
> va_end(args) : clean the variable arguments to prevent memory leaks by reclaiming resources

## /rpi_kernel_src/linux/kernel # vi kthread.c
```c
 414 struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),
 415                                                     void *data, int node,
 416                                                     const char namefmt[],
 417                                                     va_list args)
 418 {
 419         DECLARE_COMPLETION_ONSTACK(done);
 420         struct task_struct *task;
 421         struct kthread_create_info *create = kmalloc(sizeof(*create),
 422                                                      GFP_KERNEL);
 // making struct to store data for the new thread
 423
 424         if (!create)
 425                 return ERR_PTR(-ENOMEM);
 426         create->threadfn = threadfn;
 427         create->data = data;
 428         create->node = node;
 429         create->done = &done;
 430
 431         spin_lock(&kthread_create_lock); // synchronization techniques
 432         list_add_tail(&create->list, &kthread_create_list); // add to list: after this adding, kthreadd process will make a kernel process for this
 433         spin_unlock(&kthread_create_lock); // and then unlock
 434
 435         wake_up_process(kthreadd_task);
 436         /*
 437          * Wait for completion in killable state, for I might be chosen by
 438          * the OOM killer while kthreadd is trying to allocate memory for
 439          * new kernel thread.
 440          */
 441         if (unlikely(wait_for_completion_killable(&done))) {
 442                 /*
 443                  * If I was killed by a fatal signal before kthreadd (or new
 444                  * kernel thread) calls complete(), leave the cleanup of this
 445                  * structure to that thread.
 446                  */
 447                 if (xchg(&create->done, NULL))
 448                         return ERR_PTR(-EINTR);
 449                 /*
 450                  * kthreadd (or new kernel thread) will call complete()
 451                  * shortly.
 452                  */
 453                 wait_for_completion(&done);
 454         }
 455         task = create->result;
 456         if (!IS_ERR(task)) {
 457                 char name[TASK_COMM_LEN];
 458                 va_list aq;
 459                 int len;
 460
 461                 /*
 462                  * task is already visible to other tasks, so updating
 463                  * COMM must be protected.
 464                  */
 465                 va_copy(aq, args);
 466                 len = vsnprintf(name, sizeof(name), namefmt, aq);
 467                 va_end(aq);
 468                 if (len >= TASK_COMM_LEN) {
 469                         struct kthread *kthread = to_kthread(task);
 470
 471                         /* leave it truncated when out of memory. */
 472                         kthread->full_name = kvasprintf(GFP_KERNEL, namefmt, args);
 473                 }
 474                 set_task_comm(task, name);
 475         }
 476         kfree(create);
 477         return task;
 478 }
```

> wake_up_process(kthreadd_task);
> : if kthreadd process is waken up, kthreadd() which the handler function of kthreadd process works

## /rpi_kernel_src/linux/kernel # vi kthread.c
```c
 718 int kthreadd(void *unused)
 719 {
 720         struct task_struct *tsk = current;
 721
 722         /* Setup a clean context for our children to inherit. */
 723         set_task_comm(tsk, "kthreadd");
 724         ignore_signals(tsk);
 725         set_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_TYPE_KTHREAD));
 726         set_mems_allowed(node_states[N_MEMORY]);
 727
 728         current->flags |= PF_NOFREEZE;
 729         cgroup_init_kthreadd();
 730
 731         for (;;) {
 732                 set_current_state(TASK_INTERRUPTIBLE);
 733                 if (list_empty(&kthread_create_list))
 734                         schedule();
 // if the list is empty, put the current executing thread into the wait queue 
 // and yield the CPU to allow the scheduler to execute the next scheduled thread
 735                 __set_current_state(TASK_RUNNING);  // else, running
 736
 737                 spin_lock(&kthread_create_lock);  // lock
 738                 while (!list_empty(&kthread_create_list)) {
 739                         struct kthread_create_info *create;
 740
 741                         create = list_entry(kthread_create_list.next,
 742                                             struct kthread_create_info, list);
 // list_entry is a macro function, 
 // extracting a pointer to a struct kthread_create_info from the kthread_create_list linked list.
 743                         list_del_init(&create->list);
 744                         spin_unlock(&kthread_create_lock);
 745
 746                         create_kthread(create); // create thread
 747
 748                         spin_lock(&kthread_create_lock);
 749                 }
 750                 spin_unlock(&kthread_create_lock);
 751         }
 752
 753         return 0;
 754 }
 755
 ```

 ## /rpi_kernel_src/linux/kernel # vi kthread.c
 ```c
 35 static LIST_HEAD(kthread_create_list);
 ```

## /rpi_kernel_src/linux/include/linux # vi list.h
```c
23 #define LIST_HEAD_INIT(name) { &(name), &(name)}
24
25 #define LIST_HEAD(name) \
26      struct list_head name = LIST_HEAD_INIT(name)
```

## /rpi_kernel_src/linux/include/linux # vi types.h
```c
178 struct list_head {
    struct list_head *next, *prev;
};
```


## /rpi_kernel_src/linux/kernel # vi kthread.c
```c
  38 struct kthread_create_info
  39 {
  40         /* Information passed to kthread() from kthreadd. */
  41         int (*threadfn)(void *data);
  42         void *data;
  43         int node;
  44
  45         /* Result passed back to kthread_create() from kthreadd. */
  46         struct task_struct *result;
  47         struct completion *done;
  48
  49         struct list_head list;
  50 };
```

## /rpi_kernel_src/linux/kernel # vi kthread.c
```c
 391 static void create_kthread(struct kthread_create_info *create)
 392 {
 393         int pid;
 394
 395 #ifdef CONFIG_NUMA
 396         current->pref_node_fork = create->node;
 397 #endif
 398         /* We want our own signal handler (we take no signals by default). */
 399         pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);
 400         if (pid < 0) {
 401                 /* Release the structure when caller killed by a fatal signal. */
 402                 struct completion *done = xchg(&create->done, NULL);
 403
 404                 if (!done) {
 405                         kfree(create);
 406                         return;
 407                 }
 408                 create->result = ERR_PTR(pid);
 409                 complete(done);
 410         }
 411 }
```